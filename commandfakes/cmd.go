// Code generated by counterfeiter. DO NOT EDIT.
package commandfakes

import (
	"io"
	"os"
	"sync"
	"syscall"

	"github.com/BooleanCat/go-command"
)

type FakeCmd struct {
	CombinedOutputStub        func() ([]byte, error)
	combinedOutputMutex       sync.RWMutex
	combinedOutputArgsForCall []struct{}
	combinedOutputReturns     struct {
		result1 []byte
		result2 error
	}
	combinedOutputReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	OutputStub        func() ([]byte, error)
	outputMutex       sync.RWMutex
	outputArgsForCall []struct{}
	outputReturns     struct {
		result1 []byte
		result2 error
	}
	outputReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	RunStub        func() error
	runMutex       sync.RWMutex
	runArgsForCall []struct{}
	runReturns     struct {
		result1 error
	}
	runReturnsOnCall map[int]struct {
		result1 error
	}
	StartStub        func() error
	startMutex       sync.RWMutex
	startArgsForCall []struct{}
	startReturns     struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StdinPipeStub        func() (io.WriteCloser, error)
	stdinPipeMutex       sync.RWMutex
	stdinPipeArgsForCall []struct{}
	stdinPipeReturns     struct {
		result1 io.WriteCloser
		result2 error
	}
	stdinPipeReturnsOnCall map[int]struct {
		result1 io.WriteCloser
		result2 error
	}
	StdoutPipeStub        func() (io.ReadCloser, error)
	stdoutPipeMutex       sync.RWMutex
	stdoutPipeArgsForCall []struct{}
	stdoutPipeReturns     struct {
		result1 io.ReadCloser
		result2 error
	}
	stdoutPipeReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	StderrPipeStub        func() (io.ReadCloser, error)
	stderrPipeMutex       sync.RWMutex
	stderrPipeArgsForCall []struct{}
	stderrPipeReturns     struct {
		result1 io.ReadCloser
		result2 error
	}
	stderrPipeReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	WaitStub        func() error
	waitMutex       sync.RWMutex
	waitArgsForCall []struct{}
	waitReturns     struct {
		result1 error
	}
	waitReturnsOnCall map[int]struct {
		result1 error
	}
	GetPathStub        func() string
	getPathMutex       sync.RWMutex
	getPathArgsForCall []struct{}
	getPathReturns     struct {
		result1 string
	}
	getPathReturnsOnCall map[int]struct {
		result1 string
	}
	SetPathStub        func(string) command.Cmd
	setPathMutex       sync.RWMutex
	setPathArgsForCall []struct {
		arg1 string
	}
	setPathReturns struct {
		result1 command.Cmd
	}
	setPathReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetArgsStub        func() []string
	getArgsMutex       sync.RWMutex
	getArgsArgsForCall []struct{}
	getArgsReturns     struct {
		result1 []string
	}
	getArgsReturnsOnCall map[int]struct {
		result1 []string
	}
	SetArgsStub        func([]string) command.Cmd
	setArgsMutex       sync.RWMutex
	setArgsArgsForCall []struct {
		arg1 []string
	}
	setArgsReturns struct {
		result1 command.Cmd
	}
	setArgsReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetEnvStub        func() []string
	getEnvMutex       sync.RWMutex
	getEnvArgsForCall []struct{}
	getEnvReturns     struct {
		result1 []string
	}
	getEnvReturnsOnCall map[int]struct {
		result1 []string
	}
	SetEnvStub        func([]string) command.Cmd
	setEnvMutex       sync.RWMutex
	setEnvArgsForCall []struct {
		arg1 []string
	}
	setEnvReturns struct {
		result1 command.Cmd
	}
	setEnvReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetDirStub        func() string
	getDirMutex       sync.RWMutex
	getDirArgsForCall []struct{}
	getDirReturns     struct {
		result1 string
	}
	getDirReturnsOnCall map[int]struct {
		result1 string
	}
	SetDirStub        func(string) command.Cmd
	setDirMutex       sync.RWMutex
	setDirArgsForCall []struct {
		arg1 string
	}
	setDirReturns struct {
		result1 command.Cmd
	}
	setDirReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetStdinStub        func() io.Reader
	getStdinMutex       sync.RWMutex
	getStdinArgsForCall []struct{}
	getStdinReturns     struct {
		result1 io.Reader
	}
	getStdinReturnsOnCall map[int]struct {
		result1 io.Reader
	}
	SetStdinStub        func(io.Reader) command.Cmd
	setStdinMutex       sync.RWMutex
	setStdinArgsForCall []struct {
		arg1 io.Reader
	}
	setStdinReturns struct {
		result1 command.Cmd
	}
	setStdinReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetStdoutStub        func() io.Writer
	getStdoutMutex       sync.RWMutex
	getStdoutArgsForCall []struct{}
	getStdoutReturns     struct {
		result1 io.Writer
	}
	getStdoutReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	SetStdoutStub        func(io.Writer) command.Cmd
	setStdoutMutex       sync.RWMutex
	setStdoutArgsForCall []struct {
		arg1 io.Writer
	}
	setStdoutReturns struct {
		result1 command.Cmd
	}
	setStdoutReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetStderrStub        func() io.Writer
	getStderrMutex       sync.RWMutex
	getStderrArgsForCall []struct{}
	getStderrReturns     struct {
		result1 io.Writer
	}
	getStderrReturnsOnCall map[int]struct {
		result1 io.Writer
	}
	SetStderrStub        func(io.Writer) command.Cmd
	setStderrMutex       sync.RWMutex
	setStderrArgsForCall []struct {
		arg1 io.Writer
	}
	setStderrReturns struct {
		result1 command.Cmd
	}
	setStderrReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetExtraFilesStub        func() []*os.File
	getExtraFilesMutex       sync.RWMutex
	getExtraFilesArgsForCall []struct{}
	getExtraFilesReturns     struct {
		result1 []*os.File
	}
	getExtraFilesReturnsOnCall map[int]struct {
		result1 []*os.File
	}
	SetExtraFilesStub        func([]*os.File) command.Cmd
	setExtraFilesMutex       sync.RWMutex
	setExtraFilesArgsForCall []struct {
		arg1 []*os.File
	}
	setExtraFilesReturns struct {
		result1 command.Cmd
	}
	setExtraFilesReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetSysProcAttrStub        func() *syscall.SysProcAttr
	getSysProcAttrMutex       sync.RWMutex
	getSysProcAttrArgsForCall []struct{}
	getSysProcAttrReturns     struct {
		result1 *syscall.SysProcAttr
	}
	getSysProcAttrReturnsOnCall map[int]struct {
		result1 *syscall.SysProcAttr
	}
	SetSysProcAttrStub        func(*syscall.SysProcAttr) command.Cmd
	setSysProcAttrMutex       sync.RWMutex
	setSysProcAttrArgsForCall []struct {
		arg1 *syscall.SysProcAttr
	}
	setSysProcAttrReturns struct {
		result1 command.Cmd
	}
	setSysProcAttrReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetProcessStub        func() command.Process
	getProcessMutex       sync.RWMutex
	getProcessArgsForCall []struct{}
	getProcessReturns     struct {
		result1 command.Process
	}
	getProcessReturnsOnCall map[int]struct {
		result1 command.Process
	}
	SetProcessStub        func(process *os.Process) command.Cmd
	setProcessMutex       sync.RWMutex
	setProcessArgsForCall []struct {
		process *os.Process
	}
	setProcessReturns struct {
		result1 command.Cmd
	}
	setProcessReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	GetProcessStateStub        func() *os.ProcessState
	getProcessStateMutex       sync.RWMutex
	getProcessStateArgsForCall []struct{}
	getProcessStateReturns     struct {
		result1 *os.ProcessState
	}
	getProcessStateReturnsOnCall map[int]struct {
		result1 *os.ProcessState
	}
	SetProcessStateStub        func(*os.ProcessState) command.Cmd
	setProcessStateMutex       sync.RWMutex
	setProcessStateArgsForCall []struct {
		arg1 *os.ProcessState
	}
	setProcessStateReturns struct {
		result1 command.Cmd
	}
	setProcessStateReturnsOnCall map[int]struct {
		result1 command.Cmd
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCmd) CombinedOutput() ([]byte, error) {
	fake.combinedOutputMutex.Lock()
	ret, specificReturn := fake.combinedOutputReturnsOnCall[len(fake.combinedOutputArgsForCall)]
	fake.combinedOutputArgsForCall = append(fake.combinedOutputArgsForCall, struct{}{})
	fake.recordInvocation("CombinedOutput", []interface{}{})
	fake.combinedOutputMutex.Unlock()
	if fake.CombinedOutputStub != nil {
		return fake.CombinedOutputStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.combinedOutputReturns.result1, fake.combinedOutputReturns.result2
}

func (fake *FakeCmd) CombinedOutputCallCount() int {
	fake.combinedOutputMutex.RLock()
	defer fake.combinedOutputMutex.RUnlock()
	return len(fake.combinedOutputArgsForCall)
}

func (fake *FakeCmd) CombinedOutputReturns(result1 []byte, result2 error) {
	fake.CombinedOutputStub = nil
	fake.combinedOutputReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) CombinedOutputReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.CombinedOutputStub = nil
	if fake.combinedOutputReturnsOnCall == nil {
		fake.combinedOutputReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.combinedOutputReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) Output() ([]byte, error) {
	fake.outputMutex.Lock()
	ret, specificReturn := fake.outputReturnsOnCall[len(fake.outputArgsForCall)]
	fake.outputArgsForCall = append(fake.outputArgsForCall, struct{}{})
	fake.recordInvocation("Output", []interface{}{})
	fake.outputMutex.Unlock()
	if fake.OutputStub != nil {
		return fake.OutputStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.outputReturns.result1, fake.outputReturns.result2
}

func (fake *FakeCmd) OutputCallCount() int {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return len(fake.outputArgsForCall)
}

func (fake *FakeCmd) OutputReturns(result1 []byte, result2 error) {
	fake.OutputStub = nil
	fake.outputReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) OutputReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.OutputStub = nil
	if fake.outputReturnsOnCall == nil {
		fake.outputReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.outputReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) Run() error {
	fake.runMutex.Lock()
	ret, specificReturn := fake.runReturnsOnCall[len(fake.runArgsForCall)]
	fake.runArgsForCall = append(fake.runArgsForCall, struct{}{})
	fake.recordInvocation("Run", []interface{}{})
	fake.runMutex.Unlock()
	if fake.RunStub != nil {
		return fake.RunStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runReturns.result1
}

func (fake *FakeCmd) RunCallCount() int {
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	return len(fake.runArgsForCall)
}

func (fake *FakeCmd) RunReturns(result1 error) {
	fake.RunStub = nil
	fake.runReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCmd) RunReturnsOnCall(i int, result1 error) {
	fake.RunStub = nil
	if fake.runReturnsOnCall == nil {
		fake.runReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCmd) Start() error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct{}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		return fake.StartStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.startReturns.result1
}

func (fake *FakeCmd) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeCmd) StartReturns(result1 error) {
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCmd) StartReturnsOnCall(i int, result1 error) {
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCmd) StdinPipe() (io.WriteCloser, error) {
	fake.stdinPipeMutex.Lock()
	ret, specificReturn := fake.stdinPipeReturnsOnCall[len(fake.stdinPipeArgsForCall)]
	fake.stdinPipeArgsForCall = append(fake.stdinPipeArgsForCall, struct{}{})
	fake.recordInvocation("StdinPipe", []interface{}{})
	fake.stdinPipeMutex.Unlock()
	if fake.StdinPipeStub != nil {
		return fake.StdinPipeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stdinPipeReturns.result1, fake.stdinPipeReturns.result2
}

func (fake *FakeCmd) StdinPipeCallCount() int {
	fake.stdinPipeMutex.RLock()
	defer fake.stdinPipeMutex.RUnlock()
	return len(fake.stdinPipeArgsForCall)
}

func (fake *FakeCmd) StdinPipeReturns(result1 io.WriteCloser, result2 error) {
	fake.StdinPipeStub = nil
	fake.stdinPipeReturns = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) StdinPipeReturnsOnCall(i int, result1 io.WriteCloser, result2 error) {
	fake.StdinPipeStub = nil
	if fake.stdinPipeReturnsOnCall == nil {
		fake.stdinPipeReturnsOnCall = make(map[int]struct {
			result1 io.WriteCloser
			result2 error
		})
	}
	fake.stdinPipeReturnsOnCall[i] = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) StdoutPipe() (io.ReadCloser, error) {
	fake.stdoutPipeMutex.Lock()
	ret, specificReturn := fake.stdoutPipeReturnsOnCall[len(fake.stdoutPipeArgsForCall)]
	fake.stdoutPipeArgsForCall = append(fake.stdoutPipeArgsForCall, struct{}{})
	fake.recordInvocation("StdoutPipe", []interface{}{})
	fake.stdoutPipeMutex.Unlock()
	if fake.StdoutPipeStub != nil {
		return fake.StdoutPipeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stdoutPipeReturns.result1, fake.stdoutPipeReturns.result2
}

func (fake *FakeCmd) StdoutPipeCallCount() int {
	fake.stdoutPipeMutex.RLock()
	defer fake.stdoutPipeMutex.RUnlock()
	return len(fake.stdoutPipeArgsForCall)
}

func (fake *FakeCmd) StdoutPipeReturns(result1 io.ReadCloser, result2 error) {
	fake.StdoutPipeStub = nil
	fake.stdoutPipeReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) StdoutPipeReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.StdoutPipeStub = nil
	if fake.stdoutPipeReturnsOnCall == nil {
		fake.stdoutPipeReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.stdoutPipeReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) StderrPipe() (io.ReadCloser, error) {
	fake.stderrPipeMutex.Lock()
	ret, specificReturn := fake.stderrPipeReturnsOnCall[len(fake.stderrPipeArgsForCall)]
	fake.stderrPipeArgsForCall = append(fake.stderrPipeArgsForCall, struct{}{})
	fake.recordInvocation("StderrPipe", []interface{}{})
	fake.stderrPipeMutex.Unlock()
	if fake.StderrPipeStub != nil {
		return fake.StderrPipeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.stderrPipeReturns.result1, fake.stderrPipeReturns.result2
}

func (fake *FakeCmd) StderrPipeCallCount() int {
	fake.stderrPipeMutex.RLock()
	defer fake.stderrPipeMutex.RUnlock()
	return len(fake.stderrPipeArgsForCall)
}

func (fake *FakeCmd) StderrPipeReturns(result1 io.ReadCloser, result2 error) {
	fake.StderrPipeStub = nil
	fake.stderrPipeReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) StderrPipeReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.StderrPipeStub = nil
	if fake.stderrPipeReturnsOnCall == nil {
		fake.stderrPipeReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.stderrPipeReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeCmd) Wait() error {
	fake.waitMutex.Lock()
	ret, specificReturn := fake.waitReturnsOnCall[len(fake.waitArgsForCall)]
	fake.waitArgsForCall = append(fake.waitArgsForCall, struct{}{})
	fake.recordInvocation("Wait", []interface{}{})
	fake.waitMutex.Unlock()
	if fake.WaitStub != nil {
		return fake.WaitStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.waitReturns.result1
}

func (fake *FakeCmd) WaitCallCount() int {
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	return len(fake.waitArgsForCall)
}

func (fake *FakeCmd) WaitReturns(result1 error) {
	fake.WaitStub = nil
	fake.waitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCmd) WaitReturnsOnCall(i int, result1 error) {
	fake.WaitStub = nil
	if fake.waitReturnsOnCall == nil {
		fake.waitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeCmd) GetPath() string {
	fake.getPathMutex.Lock()
	ret, specificReturn := fake.getPathReturnsOnCall[len(fake.getPathArgsForCall)]
	fake.getPathArgsForCall = append(fake.getPathArgsForCall, struct{}{})
	fake.recordInvocation("GetPath", []interface{}{})
	fake.getPathMutex.Unlock()
	if fake.GetPathStub != nil {
		return fake.GetPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPathReturns.result1
}

func (fake *FakeCmd) GetPathCallCount() int {
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	return len(fake.getPathArgsForCall)
}

func (fake *FakeCmd) GetPathReturns(result1 string) {
	fake.GetPathStub = nil
	fake.getPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCmd) GetPathReturnsOnCall(i int, result1 string) {
	fake.GetPathStub = nil
	if fake.getPathReturnsOnCall == nil {
		fake.getPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCmd) SetPath(arg1 string) command.Cmd {
	fake.setPathMutex.Lock()
	ret, specificReturn := fake.setPathReturnsOnCall[len(fake.setPathArgsForCall)]
	fake.setPathArgsForCall = append(fake.setPathArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetPath", []interface{}{arg1})
	fake.setPathMutex.Unlock()
	if fake.SetPathStub != nil {
		return fake.SetPathStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setPathReturns.result1
}

func (fake *FakeCmd) SetPathCallCount() int {
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	return len(fake.setPathArgsForCall)
}

func (fake *FakeCmd) SetPathArgsForCall(i int) string {
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	return fake.setPathArgsForCall[i].arg1
}

func (fake *FakeCmd) SetPathReturns(result1 command.Cmd) {
	fake.SetPathStub = nil
	fake.setPathReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetPathReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetPathStub = nil
	if fake.setPathReturnsOnCall == nil {
		fake.setPathReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setPathReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetArgs() []string {
	fake.getArgsMutex.Lock()
	ret, specificReturn := fake.getArgsReturnsOnCall[len(fake.getArgsArgsForCall)]
	fake.getArgsArgsForCall = append(fake.getArgsArgsForCall, struct{}{})
	fake.recordInvocation("GetArgs", []interface{}{})
	fake.getArgsMutex.Unlock()
	if fake.GetArgsStub != nil {
		return fake.GetArgsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getArgsReturns.result1
}

func (fake *FakeCmd) GetArgsCallCount() int {
	fake.getArgsMutex.RLock()
	defer fake.getArgsMutex.RUnlock()
	return len(fake.getArgsArgsForCall)
}

func (fake *FakeCmd) GetArgsReturns(result1 []string) {
	fake.GetArgsStub = nil
	fake.getArgsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeCmd) GetArgsReturnsOnCall(i int, result1 []string) {
	fake.GetArgsStub = nil
	if fake.getArgsReturnsOnCall == nil {
		fake.getArgsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getArgsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeCmd) SetArgs(arg1 []string) command.Cmd {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setArgsMutex.Lock()
	ret, specificReturn := fake.setArgsReturnsOnCall[len(fake.setArgsArgsForCall)]
	fake.setArgsArgsForCall = append(fake.setArgsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("SetArgs", []interface{}{arg1Copy})
	fake.setArgsMutex.Unlock()
	if fake.SetArgsStub != nil {
		return fake.SetArgsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setArgsReturns.result1
}

func (fake *FakeCmd) SetArgsCallCount() int {
	fake.setArgsMutex.RLock()
	defer fake.setArgsMutex.RUnlock()
	return len(fake.setArgsArgsForCall)
}

func (fake *FakeCmd) SetArgsArgsForCall(i int) []string {
	fake.setArgsMutex.RLock()
	defer fake.setArgsMutex.RUnlock()
	return fake.setArgsArgsForCall[i].arg1
}

func (fake *FakeCmd) SetArgsReturns(result1 command.Cmd) {
	fake.SetArgsStub = nil
	fake.setArgsReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetArgsReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetArgsStub = nil
	if fake.setArgsReturnsOnCall == nil {
		fake.setArgsReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setArgsReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetEnv() []string {
	fake.getEnvMutex.Lock()
	ret, specificReturn := fake.getEnvReturnsOnCall[len(fake.getEnvArgsForCall)]
	fake.getEnvArgsForCall = append(fake.getEnvArgsForCall, struct{}{})
	fake.recordInvocation("GetEnv", []interface{}{})
	fake.getEnvMutex.Unlock()
	if fake.GetEnvStub != nil {
		return fake.GetEnvStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getEnvReturns.result1
}

func (fake *FakeCmd) GetEnvCallCount() int {
	fake.getEnvMutex.RLock()
	defer fake.getEnvMutex.RUnlock()
	return len(fake.getEnvArgsForCall)
}

func (fake *FakeCmd) GetEnvReturns(result1 []string) {
	fake.GetEnvStub = nil
	fake.getEnvReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeCmd) GetEnvReturnsOnCall(i int, result1 []string) {
	fake.GetEnvStub = nil
	if fake.getEnvReturnsOnCall == nil {
		fake.getEnvReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getEnvReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeCmd) SetEnv(arg1 []string) command.Cmd {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setEnvMutex.Lock()
	ret, specificReturn := fake.setEnvReturnsOnCall[len(fake.setEnvArgsForCall)]
	fake.setEnvArgsForCall = append(fake.setEnvArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("SetEnv", []interface{}{arg1Copy})
	fake.setEnvMutex.Unlock()
	if fake.SetEnvStub != nil {
		return fake.SetEnvStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setEnvReturns.result1
}

func (fake *FakeCmd) SetEnvCallCount() int {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	return len(fake.setEnvArgsForCall)
}

func (fake *FakeCmd) SetEnvArgsForCall(i int) []string {
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	return fake.setEnvArgsForCall[i].arg1
}

func (fake *FakeCmd) SetEnvReturns(result1 command.Cmd) {
	fake.SetEnvStub = nil
	fake.setEnvReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetEnvReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetEnvStub = nil
	if fake.setEnvReturnsOnCall == nil {
		fake.setEnvReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setEnvReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetDir() string {
	fake.getDirMutex.Lock()
	ret, specificReturn := fake.getDirReturnsOnCall[len(fake.getDirArgsForCall)]
	fake.getDirArgsForCall = append(fake.getDirArgsForCall, struct{}{})
	fake.recordInvocation("GetDir", []interface{}{})
	fake.getDirMutex.Unlock()
	if fake.GetDirStub != nil {
		return fake.GetDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getDirReturns.result1
}

func (fake *FakeCmd) GetDirCallCount() int {
	fake.getDirMutex.RLock()
	defer fake.getDirMutex.RUnlock()
	return len(fake.getDirArgsForCall)
}

func (fake *FakeCmd) GetDirReturns(result1 string) {
	fake.GetDirStub = nil
	fake.getDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCmd) GetDirReturnsOnCall(i int, result1 string) {
	fake.GetDirStub = nil
	if fake.getDirReturnsOnCall == nil {
		fake.getDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCmd) SetDir(arg1 string) command.Cmd {
	fake.setDirMutex.Lock()
	ret, specificReturn := fake.setDirReturnsOnCall[len(fake.setDirArgsForCall)]
	fake.setDirArgsForCall = append(fake.setDirArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetDir", []interface{}{arg1})
	fake.setDirMutex.Unlock()
	if fake.SetDirStub != nil {
		return fake.SetDirStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setDirReturns.result1
}

func (fake *FakeCmd) SetDirCallCount() int {
	fake.setDirMutex.RLock()
	defer fake.setDirMutex.RUnlock()
	return len(fake.setDirArgsForCall)
}

func (fake *FakeCmd) SetDirArgsForCall(i int) string {
	fake.setDirMutex.RLock()
	defer fake.setDirMutex.RUnlock()
	return fake.setDirArgsForCall[i].arg1
}

func (fake *FakeCmd) SetDirReturns(result1 command.Cmd) {
	fake.SetDirStub = nil
	fake.setDirReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetDirReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetDirStub = nil
	if fake.setDirReturnsOnCall == nil {
		fake.setDirReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setDirReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetStdin() io.Reader {
	fake.getStdinMutex.Lock()
	ret, specificReturn := fake.getStdinReturnsOnCall[len(fake.getStdinArgsForCall)]
	fake.getStdinArgsForCall = append(fake.getStdinArgsForCall, struct{}{})
	fake.recordInvocation("GetStdin", []interface{}{})
	fake.getStdinMutex.Unlock()
	if fake.GetStdinStub != nil {
		return fake.GetStdinStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStdinReturns.result1
}

func (fake *FakeCmd) GetStdinCallCount() int {
	fake.getStdinMutex.RLock()
	defer fake.getStdinMutex.RUnlock()
	return len(fake.getStdinArgsForCall)
}

func (fake *FakeCmd) GetStdinReturns(result1 io.Reader) {
	fake.GetStdinStub = nil
	fake.getStdinReturns = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeCmd) GetStdinReturnsOnCall(i int, result1 io.Reader) {
	fake.GetStdinStub = nil
	if fake.getStdinReturnsOnCall == nil {
		fake.getStdinReturnsOnCall = make(map[int]struct {
			result1 io.Reader
		})
	}
	fake.getStdinReturnsOnCall[i] = struct {
		result1 io.Reader
	}{result1}
}

func (fake *FakeCmd) SetStdin(arg1 io.Reader) command.Cmd {
	fake.setStdinMutex.Lock()
	ret, specificReturn := fake.setStdinReturnsOnCall[len(fake.setStdinArgsForCall)]
	fake.setStdinArgsForCall = append(fake.setStdinArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	fake.recordInvocation("SetStdin", []interface{}{arg1})
	fake.setStdinMutex.Unlock()
	if fake.SetStdinStub != nil {
		return fake.SetStdinStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setStdinReturns.result1
}

func (fake *FakeCmd) SetStdinCallCount() int {
	fake.setStdinMutex.RLock()
	defer fake.setStdinMutex.RUnlock()
	return len(fake.setStdinArgsForCall)
}

func (fake *FakeCmd) SetStdinArgsForCall(i int) io.Reader {
	fake.setStdinMutex.RLock()
	defer fake.setStdinMutex.RUnlock()
	return fake.setStdinArgsForCall[i].arg1
}

func (fake *FakeCmd) SetStdinReturns(result1 command.Cmd) {
	fake.SetStdinStub = nil
	fake.setStdinReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetStdinReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetStdinStub = nil
	if fake.setStdinReturnsOnCall == nil {
		fake.setStdinReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setStdinReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetStdout() io.Writer {
	fake.getStdoutMutex.Lock()
	ret, specificReturn := fake.getStdoutReturnsOnCall[len(fake.getStdoutArgsForCall)]
	fake.getStdoutArgsForCall = append(fake.getStdoutArgsForCall, struct{}{})
	fake.recordInvocation("GetStdout", []interface{}{})
	fake.getStdoutMutex.Unlock()
	if fake.GetStdoutStub != nil {
		return fake.GetStdoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStdoutReturns.result1
}

func (fake *FakeCmd) GetStdoutCallCount() int {
	fake.getStdoutMutex.RLock()
	defer fake.getStdoutMutex.RUnlock()
	return len(fake.getStdoutArgsForCall)
}

func (fake *FakeCmd) GetStdoutReturns(result1 io.Writer) {
	fake.GetStdoutStub = nil
	fake.getStdoutReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCmd) GetStdoutReturnsOnCall(i int, result1 io.Writer) {
	fake.GetStdoutStub = nil
	if fake.getStdoutReturnsOnCall == nil {
		fake.getStdoutReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.getStdoutReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCmd) SetStdout(arg1 io.Writer) command.Cmd {
	fake.setStdoutMutex.Lock()
	ret, specificReturn := fake.setStdoutReturnsOnCall[len(fake.setStdoutArgsForCall)]
	fake.setStdoutArgsForCall = append(fake.setStdoutArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("SetStdout", []interface{}{arg1})
	fake.setStdoutMutex.Unlock()
	if fake.SetStdoutStub != nil {
		return fake.SetStdoutStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setStdoutReturns.result1
}

func (fake *FakeCmd) SetStdoutCallCount() int {
	fake.setStdoutMutex.RLock()
	defer fake.setStdoutMutex.RUnlock()
	return len(fake.setStdoutArgsForCall)
}

func (fake *FakeCmd) SetStdoutArgsForCall(i int) io.Writer {
	fake.setStdoutMutex.RLock()
	defer fake.setStdoutMutex.RUnlock()
	return fake.setStdoutArgsForCall[i].arg1
}

func (fake *FakeCmd) SetStdoutReturns(result1 command.Cmd) {
	fake.SetStdoutStub = nil
	fake.setStdoutReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetStdoutReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetStdoutStub = nil
	if fake.setStdoutReturnsOnCall == nil {
		fake.setStdoutReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setStdoutReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetStderr() io.Writer {
	fake.getStderrMutex.Lock()
	ret, specificReturn := fake.getStderrReturnsOnCall[len(fake.getStderrArgsForCall)]
	fake.getStderrArgsForCall = append(fake.getStderrArgsForCall, struct{}{})
	fake.recordInvocation("GetStderr", []interface{}{})
	fake.getStderrMutex.Unlock()
	if fake.GetStderrStub != nil {
		return fake.GetStderrStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStderrReturns.result1
}

func (fake *FakeCmd) GetStderrCallCount() int {
	fake.getStderrMutex.RLock()
	defer fake.getStderrMutex.RUnlock()
	return len(fake.getStderrArgsForCall)
}

func (fake *FakeCmd) GetStderrReturns(result1 io.Writer) {
	fake.GetStderrStub = nil
	fake.getStderrReturns = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCmd) GetStderrReturnsOnCall(i int, result1 io.Writer) {
	fake.GetStderrStub = nil
	if fake.getStderrReturnsOnCall == nil {
		fake.getStderrReturnsOnCall = make(map[int]struct {
			result1 io.Writer
		})
	}
	fake.getStderrReturnsOnCall[i] = struct {
		result1 io.Writer
	}{result1}
}

func (fake *FakeCmd) SetStderr(arg1 io.Writer) command.Cmd {
	fake.setStderrMutex.Lock()
	ret, specificReturn := fake.setStderrReturnsOnCall[len(fake.setStderrArgsForCall)]
	fake.setStderrArgsForCall = append(fake.setStderrArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("SetStderr", []interface{}{arg1})
	fake.setStderrMutex.Unlock()
	if fake.SetStderrStub != nil {
		return fake.SetStderrStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setStderrReturns.result1
}

func (fake *FakeCmd) SetStderrCallCount() int {
	fake.setStderrMutex.RLock()
	defer fake.setStderrMutex.RUnlock()
	return len(fake.setStderrArgsForCall)
}

func (fake *FakeCmd) SetStderrArgsForCall(i int) io.Writer {
	fake.setStderrMutex.RLock()
	defer fake.setStderrMutex.RUnlock()
	return fake.setStderrArgsForCall[i].arg1
}

func (fake *FakeCmd) SetStderrReturns(result1 command.Cmd) {
	fake.SetStderrStub = nil
	fake.setStderrReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetStderrReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetStderrStub = nil
	if fake.setStderrReturnsOnCall == nil {
		fake.setStderrReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setStderrReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetExtraFiles() []*os.File {
	fake.getExtraFilesMutex.Lock()
	ret, specificReturn := fake.getExtraFilesReturnsOnCall[len(fake.getExtraFilesArgsForCall)]
	fake.getExtraFilesArgsForCall = append(fake.getExtraFilesArgsForCall, struct{}{})
	fake.recordInvocation("GetExtraFiles", []interface{}{})
	fake.getExtraFilesMutex.Unlock()
	if fake.GetExtraFilesStub != nil {
		return fake.GetExtraFilesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getExtraFilesReturns.result1
}

func (fake *FakeCmd) GetExtraFilesCallCount() int {
	fake.getExtraFilesMutex.RLock()
	defer fake.getExtraFilesMutex.RUnlock()
	return len(fake.getExtraFilesArgsForCall)
}

func (fake *FakeCmd) GetExtraFilesReturns(result1 []*os.File) {
	fake.GetExtraFilesStub = nil
	fake.getExtraFilesReturns = struct {
		result1 []*os.File
	}{result1}
}

func (fake *FakeCmd) GetExtraFilesReturnsOnCall(i int, result1 []*os.File) {
	fake.GetExtraFilesStub = nil
	if fake.getExtraFilesReturnsOnCall == nil {
		fake.getExtraFilesReturnsOnCall = make(map[int]struct {
			result1 []*os.File
		})
	}
	fake.getExtraFilesReturnsOnCall[i] = struct {
		result1 []*os.File
	}{result1}
}

func (fake *FakeCmd) SetExtraFiles(arg1 []*os.File) command.Cmd {
	var arg1Copy []*os.File
	if arg1 != nil {
		arg1Copy = make([]*os.File, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setExtraFilesMutex.Lock()
	ret, specificReturn := fake.setExtraFilesReturnsOnCall[len(fake.setExtraFilesArgsForCall)]
	fake.setExtraFilesArgsForCall = append(fake.setExtraFilesArgsForCall, struct {
		arg1 []*os.File
	}{arg1Copy})
	fake.recordInvocation("SetExtraFiles", []interface{}{arg1Copy})
	fake.setExtraFilesMutex.Unlock()
	if fake.SetExtraFilesStub != nil {
		return fake.SetExtraFilesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setExtraFilesReturns.result1
}

func (fake *FakeCmd) SetExtraFilesCallCount() int {
	fake.setExtraFilesMutex.RLock()
	defer fake.setExtraFilesMutex.RUnlock()
	return len(fake.setExtraFilesArgsForCall)
}

func (fake *FakeCmd) SetExtraFilesArgsForCall(i int) []*os.File {
	fake.setExtraFilesMutex.RLock()
	defer fake.setExtraFilesMutex.RUnlock()
	return fake.setExtraFilesArgsForCall[i].arg1
}

func (fake *FakeCmd) SetExtraFilesReturns(result1 command.Cmd) {
	fake.SetExtraFilesStub = nil
	fake.setExtraFilesReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetExtraFilesReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetExtraFilesStub = nil
	if fake.setExtraFilesReturnsOnCall == nil {
		fake.setExtraFilesReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setExtraFilesReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetSysProcAttr() *syscall.SysProcAttr {
	fake.getSysProcAttrMutex.Lock()
	ret, specificReturn := fake.getSysProcAttrReturnsOnCall[len(fake.getSysProcAttrArgsForCall)]
	fake.getSysProcAttrArgsForCall = append(fake.getSysProcAttrArgsForCall, struct{}{})
	fake.recordInvocation("GetSysProcAttr", []interface{}{})
	fake.getSysProcAttrMutex.Unlock()
	if fake.GetSysProcAttrStub != nil {
		return fake.GetSysProcAttrStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getSysProcAttrReturns.result1
}

func (fake *FakeCmd) GetSysProcAttrCallCount() int {
	fake.getSysProcAttrMutex.RLock()
	defer fake.getSysProcAttrMutex.RUnlock()
	return len(fake.getSysProcAttrArgsForCall)
}

func (fake *FakeCmd) GetSysProcAttrReturns(result1 *syscall.SysProcAttr) {
	fake.GetSysProcAttrStub = nil
	fake.getSysProcAttrReturns = struct {
		result1 *syscall.SysProcAttr
	}{result1}
}

func (fake *FakeCmd) GetSysProcAttrReturnsOnCall(i int, result1 *syscall.SysProcAttr) {
	fake.GetSysProcAttrStub = nil
	if fake.getSysProcAttrReturnsOnCall == nil {
		fake.getSysProcAttrReturnsOnCall = make(map[int]struct {
			result1 *syscall.SysProcAttr
		})
	}
	fake.getSysProcAttrReturnsOnCall[i] = struct {
		result1 *syscall.SysProcAttr
	}{result1}
}

func (fake *FakeCmd) SetSysProcAttr(arg1 *syscall.SysProcAttr) command.Cmd {
	fake.setSysProcAttrMutex.Lock()
	ret, specificReturn := fake.setSysProcAttrReturnsOnCall[len(fake.setSysProcAttrArgsForCall)]
	fake.setSysProcAttrArgsForCall = append(fake.setSysProcAttrArgsForCall, struct {
		arg1 *syscall.SysProcAttr
	}{arg1})
	fake.recordInvocation("SetSysProcAttr", []interface{}{arg1})
	fake.setSysProcAttrMutex.Unlock()
	if fake.SetSysProcAttrStub != nil {
		return fake.SetSysProcAttrStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setSysProcAttrReturns.result1
}

func (fake *FakeCmd) SetSysProcAttrCallCount() int {
	fake.setSysProcAttrMutex.RLock()
	defer fake.setSysProcAttrMutex.RUnlock()
	return len(fake.setSysProcAttrArgsForCall)
}

func (fake *FakeCmd) SetSysProcAttrArgsForCall(i int) *syscall.SysProcAttr {
	fake.setSysProcAttrMutex.RLock()
	defer fake.setSysProcAttrMutex.RUnlock()
	return fake.setSysProcAttrArgsForCall[i].arg1
}

func (fake *FakeCmd) SetSysProcAttrReturns(result1 command.Cmd) {
	fake.SetSysProcAttrStub = nil
	fake.setSysProcAttrReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetSysProcAttrReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetSysProcAttrStub = nil
	if fake.setSysProcAttrReturnsOnCall == nil {
		fake.setSysProcAttrReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setSysProcAttrReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetProcess() command.Process {
	fake.getProcessMutex.Lock()
	ret, specificReturn := fake.getProcessReturnsOnCall[len(fake.getProcessArgsForCall)]
	fake.getProcessArgsForCall = append(fake.getProcessArgsForCall, struct{}{})
	fake.recordInvocation("GetProcess", []interface{}{})
	fake.getProcessMutex.Unlock()
	if fake.GetProcessStub != nil {
		return fake.GetProcessStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getProcessReturns.result1
}

func (fake *FakeCmd) GetProcessCallCount() int {
	fake.getProcessMutex.RLock()
	defer fake.getProcessMutex.RUnlock()
	return len(fake.getProcessArgsForCall)
}

func (fake *FakeCmd) GetProcessReturns(result1 command.Process) {
	fake.GetProcessStub = nil
	fake.getProcessReturns = struct {
		result1 command.Process
	}{result1}
}

func (fake *FakeCmd) GetProcessReturnsOnCall(i int, result1 command.Process) {
	fake.GetProcessStub = nil
	if fake.getProcessReturnsOnCall == nil {
		fake.getProcessReturnsOnCall = make(map[int]struct {
			result1 command.Process
		})
	}
	fake.getProcessReturnsOnCall[i] = struct {
		result1 command.Process
	}{result1}
}

func (fake *FakeCmd) SetProcess(process *os.Process) command.Cmd {
	fake.setProcessMutex.Lock()
	ret, specificReturn := fake.setProcessReturnsOnCall[len(fake.setProcessArgsForCall)]
	fake.setProcessArgsForCall = append(fake.setProcessArgsForCall, struct {
		process *os.Process
	}{process})
	fake.recordInvocation("SetProcess", []interface{}{process})
	fake.setProcessMutex.Unlock()
	if fake.SetProcessStub != nil {
		return fake.SetProcessStub(process)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setProcessReturns.result1
}

func (fake *FakeCmd) SetProcessCallCount() int {
	fake.setProcessMutex.RLock()
	defer fake.setProcessMutex.RUnlock()
	return len(fake.setProcessArgsForCall)
}

func (fake *FakeCmd) SetProcessArgsForCall(i int) *os.Process {
	fake.setProcessMutex.RLock()
	defer fake.setProcessMutex.RUnlock()
	return fake.setProcessArgsForCall[i].process
}

func (fake *FakeCmd) SetProcessReturns(result1 command.Cmd) {
	fake.SetProcessStub = nil
	fake.setProcessReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetProcessReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetProcessStub = nil
	if fake.setProcessReturnsOnCall == nil {
		fake.setProcessReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setProcessReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) GetProcessState() *os.ProcessState {
	fake.getProcessStateMutex.Lock()
	ret, specificReturn := fake.getProcessStateReturnsOnCall[len(fake.getProcessStateArgsForCall)]
	fake.getProcessStateArgsForCall = append(fake.getProcessStateArgsForCall, struct{}{})
	fake.recordInvocation("GetProcessState", []interface{}{})
	fake.getProcessStateMutex.Unlock()
	if fake.GetProcessStateStub != nil {
		return fake.GetProcessStateStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getProcessStateReturns.result1
}

func (fake *FakeCmd) GetProcessStateCallCount() int {
	fake.getProcessStateMutex.RLock()
	defer fake.getProcessStateMutex.RUnlock()
	return len(fake.getProcessStateArgsForCall)
}

func (fake *FakeCmd) GetProcessStateReturns(result1 *os.ProcessState) {
	fake.GetProcessStateStub = nil
	fake.getProcessStateReturns = struct {
		result1 *os.ProcessState
	}{result1}
}

func (fake *FakeCmd) GetProcessStateReturnsOnCall(i int, result1 *os.ProcessState) {
	fake.GetProcessStateStub = nil
	if fake.getProcessStateReturnsOnCall == nil {
		fake.getProcessStateReturnsOnCall = make(map[int]struct {
			result1 *os.ProcessState
		})
	}
	fake.getProcessStateReturnsOnCall[i] = struct {
		result1 *os.ProcessState
	}{result1}
}

func (fake *FakeCmd) SetProcessState(arg1 *os.ProcessState) command.Cmd {
	fake.setProcessStateMutex.Lock()
	ret, specificReturn := fake.setProcessStateReturnsOnCall[len(fake.setProcessStateArgsForCall)]
	fake.setProcessStateArgsForCall = append(fake.setProcessStateArgsForCall, struct {
		arg1 *os.ProcessState
	}{arg1})
	fake.recordInvocation("SetProcessState", []interface{}{arg1})
	fake.setProcessStateMutex.Unlock()
	if fake.SetProcessStateStub != nil {
		return fake.SetProcessStateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setProcessStateReturns.result1
}

func (fake *FakeCmd) SetProcessStateCallCount() int {
	fake.setProcessStateMutex.RLock()
	defer fake.setProcessStateMutex.RUnlock()
	return len(fake.setProcessStateArgsForCall)
}

func (fake *FakeCmd) SetProcessStateArgsForCall(i int) *os.ProcessState {
	fake.setProcessStateMutex.RLock()
	defer fake.setProcessStateMutex.RUnlock()
	return fake.setProcessStateArgsForCall[i].arg1
}

func (fake *FakeCmd) SetProcessStateReturns(result1 command.Cmd) {
	fake.SetProcessStateStub = nil
	fake.setProcessStateReturns = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) SetProcessStateReturnsOnCall(i int, result1 command.Cmd) {
	fake.SetProcessStateStub = nil
	if fake.setProcessStateReturnsOnCall == nil {
		fake.setProcessStateReturnsOnCall = make(map[int]struct {
			result1 command.Cmd
		})
	}
	fake.setProcessStateReturnsOnCall[i] = struct {
		result1 command.Cmd
	}{result1}
}

func (fake *FakeCmd) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.combinedOutputMutex.RLock()
	defer fake.combinedOutputMutex.RUnlock()
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	fake.runMutex.RLock()
	defer fake.runMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stdinPipeMutex.RLock()
	defer fake.stdinPipeMutex.RUnlock()
	fake.stdoutPipeMutex.RLock()
	defer fake.stdoutPipeMutex.RUnlock()
	fake.stderrPipeMutex.RLock()
	defer fake.stderrPipeMutex.RUnlock()
	fake.waitMutex.RLock()
	defer fake.waitMutex.RUnlock()
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	fake.getArgsMutex.RLock()
	defer fake.getArgsMutex.RUnlock()
	fake.setArgsMutex.RLock()
	defer fake.setArgsMutex.RUnlock()
	fake.getEnvMutex.RLock()
	defer fake.getEnvMutex.RUnlock()
	fake.setEnvMutex.RLock()
	defer fake.setEnvMutex.RUnlock()
	fake.getDirMutex.RLock()
	defer fake.getDirMutex.RUnlock()
	fake.setDirMutex.RLock()
	defer fake.setDirMutex.RUnlock()
	fake.getStdinMutex.RLock()
	defer fake.getStdinMutex.RUnlock()
	fake.setStdinMutex.RLock()
	defer fake.setStdinMutex.RUnlock()
	fake.getStdoutMutex.RLock()
	defer fake.getStdoutMutex.RUnlock()
	fake.setStdoutMutex.RLock()
	defer fake.setStdoutMutex.RUnlock()
	fake.getStderrMutex.RLock()
	defer fake.getStderrMutex.RUnlock()
	fake.setStderrMutex.RLock()
	defer fake.setStderrMutex.RUnlock()
	fake.getExtraFilesMutex.RLock()
	defer fake.getExtraFilesMutex.RUnlock()
	fake.setExtraFilesMutex.RLock()
	defer fake.setExtraFilesMutex.RUnlock()
	fake.getSysProcAttrMutex.RLock()
	defer fake.getSysProcAttrMutex.RUnlock()
	fake.setSysProcAttrMutex.RLock()
	defer fake.setSysProcAttrMutex.RUnlock()
	fake.getProcessMutex.RLock()
	defer fake.getProcessMutex.RUnlock()
	fake.setProcessMutex.RLock()
	defer fake.setProcessMutex.RUnlock()
	fake.getProcessStateMutex.RLock()
	defer fake.getProcessStateMutex.RUnlock()
	fake.setProcessStateMutex.RLock()
	defer fake.setProcessStateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCmd) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ command.Cmd = new(FakeCmd)
